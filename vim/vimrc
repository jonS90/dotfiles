:scriptencoding utf8
:let s:vimrcIsExecuting = 1
if !exists('s:os')
  if has('win64') || has('win32') || has('win16')
    let s:os = 'Windows'
  else
    let s:os = substitute(system('uname'), '\n', '', '')
  endif
endif
:let g:mapleader = ' '

" Install vim-plug
if (s:os != 'Windows')
  if empty(glob('~/.vim/autoload/plug.vim'))
    silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
          \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
    augroup vimplug
      autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
    augroup END
  endif
else
  if empty(glob('~\vimfiles\autoload\plug.vim'))
    set shell=C:\\WINDOWS\\sysnative\\WindowsPowerShell\\v1.0\\powershell.exe
    !md ~\vimfiles\autoload
    !(New-Object Net.WebClient).DownloadFile('https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim', $ExecutionContext.SessionState.Path.GetUnresolvedProviderPathFromPSPath('~\vimfiles\autoload\plug.vim'))
    augroup vimplug
      autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
    augroup END
  endif
endif

" VIM PLUG
  call plug#begin('~/.vim/plugged')

    Plug 'AndrewRadev/splitjoin.vim'
    " gJ on first line to join object literal into one line
    " gS to split one-line object into multiple lines

    " Plug 'airblade/vim-gitgutter'
    " Show indicators for what's been modified/added/deleted.
    " :nmap <Leader>ga :GitGutterStageHunk<Enter>
    " :nmap <Leader>ga :GitGutterStageHunk<Enter>
    " :nmap <Leader>gH :GitGutterLineHighlightsToggle<Enter>
    " :nmap <Leader>gn :GitGutterNextHunk<Enter>
    " :nmap <Leader>gN :GitGutterPrevHunk<Enter>
    " :nmap <Leader>gP :GitGutterPreviewHunk<Enter>
    " :nmap <Leader>gu :GitGutterUndoHunk<Enter>

    Plug 'mhinz/vim-signify'
    " Git info in gutter
    " [c,]c jump to prev/next change
    " [C,]C jump to last/first change

    Plug 'alvan/vim-closetag'
    " Automatically close html tags.

    Plug 'ciaranm/detectindent'
    " Analyze current buffer and configure tabbing to match.

    Plug 'chrisbra/Colorizer'
    " Show hex colors by running :ColorHighlight or :ColorToggle

    Plug 'editorconfig/editorconfig-vim'
    " Configure different coding styles on a per-project basis and have vim
    " automatically adjust. There are equivalent plugins for all major code
    " editors. It's great. In a better world, every project would have a
    " .editorconfig file at its root.

    Plug 'itchyny/lightline.vim'
    " inspired by https://statico.github.io/vim3.html#lightline-powerline-airline-and-status-bars
      set laststatus=2 "always show airline, instead of only after splitview
      set noshowmode   "lightline will show mode for me
      set showcmd      "shows size of visual selection BELOW lightline
      let g:lightline = {
      \   'active': {
      \     'left': [
      \       ['mode', 'paste'],
      \       ['filename', 'modified'],
      \       ['git_changes'],
      \     ],
      \     'right': [
      \       ['lineinfo'],
      \       ['percent'],
      \       ['readonly', 'linter_warnings', 'linter_errors', 'linter_ok'],
      \       ['obsession'],
      \     ]
      \   },
      \   'component_function': {
      \     'obsession':   'LightlineObsessionStatus',
      \     'git_changes': 'LightLineChanges',
      \   },
      \   'component_expand': {
      \     'linter_warnings': 'LightlineLinterWarnings',
      \     'linter_errors':   'LightlineLinterErrors',
      \     'linter_ok':       'LightlineLinterOK',
      \   },
      \   'component_type': {
      \     'readonly':        'error',
      \     'linter_warnings': 'warning',
      \     'linter_errors':   'error'
      \   },
      \   'separator': {
      \     'left': '',
      \     'right': ''
      \   },
      \   'enable': {
      \     'statusline': 1,
      \     'tabline': 0
      \   }
      \ }
      " let g:lightline.separator.right = ''
      " let g:lightline.separator.left =  ''
      function! LightlineObsessionStatus()
        if exists('*ObsessionStatus')
          return ObsessionStatus('session', 'session paused')
        endif
      endfunction
      function! LightLineChanges()
        let l:hunkSummary = v:null
        if exists('*GitGutterGetHunkSummary')
          let l:hunkSummary = GitGutterGetHunkSummary()
        elseif exists('g:loaded_signify') && sy#buffer_is_active()
          let l:hunkSummary = sy#repo#get_stats()
        endif
        if (empty(l:hunkSummary))
          return ''
        else
          let [ l:added, l:modified, l:removed ] = l:hunkSummary
          let l:total = (l:added + l:modified + l:removed)
          let l:output = ''
          if (l:added != 0)
            let l:output .= printf('+%d ', l:added)
          endif
          if (l:modified != 0)
            let l:output .= printf('~%d ', l:modified)
          endif
          if (l:removed != 0)
            let l:output .= printf('-%d ', l:removed)
          endif
          return '(' . l:output . ')'
        endif
      endfunction
      function! LightlineLinterWarnings() abort
        if (&readonly)
          return ''
        endif
        let l:counts = ale#statusline#Count(bufnr(''))
        let l:all_errors = l:counts.error + l:counts.style_error
        let l:all_non_errors = l:counts.total - l:all_errors
        return l:all_non_errors == 0 ? '' : printf('%d ▲', l:all_non_errors)
      endfunction
      function! LightlineLinterErrors() abort
        if (&readonly)
          return ''
        endif
        let l:counts = ale#statusline#Count(bufnr(''))
        let l:all_errors = l:counts.error + l:counts.style_error
        let l:all_non_errors = l:counts.total - l:all_errors
        return l:all_errors == 0 ? '' : printf('%d ✗', l:all_errors)
      endfunction
      function! LightlineLinterOK() abort
        if (&readonly)
          return ''
        endif
        let l:counts = ale#statusline#Count(bufnr(''))
        let l:all_errors = l:counts.error + l:counts.style_error
        let l:all_non_errors = l:counts.total - l:all_errors
        return l:counts.total == 0 ? '✓' : ''
      endfunction
      augroup ale_stuff
        autocmd User ALELint call s:MaybeUpdateLightline()
      augroup END
      function! s:MaybeUpdateLightline()
        " Update and show lightline but only if it's visible (e.g., not in Goyo)
        if exists('#lightline')
          call lightline#update()
        end
      endfunction

    Plug 'jonsmithers/vim-html-template-literals'

    Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all --no-zsh' }
    Plug 'junegunn/fzf.vim'
    " Incredible fuzzy search for all sorts of things. Best plugin ever.

      " customize fzf colors to match color scheme
        let g:fzf_colors =
        \ { 'fg':      ['fg', 'Normal'],
          \ 'bg':      ['bg', 'Normal'],
          \ 'hl':      ['fg', 'Comment'],
          \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
          \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
          \ 'hl+':     ['fg', 'Statement'],
          \ 'info':    ['fg', 'PreProc'],
          \ 'border':  ['fg', 'Ignore'],
          \ 'prompt':  ['fg', 'Conditional'],
          \ 'pointer': ['fg', 'Exception'],
          \ 'marker':  ['fg', 'Keyword'],
          \ 'spinner': ['fg', 'Label'],
          \ 'header':  ['fg', 'Comment'] }

      " fzf bindings
        :command! -bang -nargs=* Rg  call fzf#vim#grep('rg --column --line-number --no-heading --color=always               '.shellescape(<q-args>).'| tr -d "\017"', 1, <bang>0)
        :command! -bang -nargs=* Rgi call fzf#vim#grep('rg --column --line-number --no-heading --color=always --ignore-case '.shellescape(<q-args>).'| tr -d "\017"', 1, <bang>0)
        :command! -nargs=* Rgexpand :exec 'Rg ' . expand(<q-args>)

        "search for word in working directory
        :nnoremap <Leader>sw    :Rg  
        :vnoremap <Leader>s     y:Rg "<Enter>

        :nnoremap <C-k>         :Buffers<Enter>
        :nnoremap <C-p>         :Files<Enter>
        :nnoremap <Leader>or    :History<Enter>
        :nnoremap <Leader>ft    :Filetypes<enter>
        :nnoremap <Leader>/     :History/<Enter>
        :nnoremap <Leader><C-r> :History:<Enter>
        " (note - you can call histdel("cmd", "regexp") to delete mistaken history items)
        " :nmap <Leader>f~    :FZF ~<Enter>

        " fuzzy relative filepath completion!
        inoremap <expr> <c-x><c-f> fzf#vim#complete#path(
              \ "find . -path '*/\.*' -prune -o -print \| sed '1d;s:^..::'",
              \ fzf#wrap({'dir': expand('%:p:h')}))
        inoremap <c-x>F <c-x><c-f>
              " Ctrl-X Shift-F will provide native c-x c-f functionality

      " rg-results in quickfix (https://github.com/junegunn/fzf/wiki/Examples-(vim)#narrow-ag-results-within-vim)
        "command! -nargs=* Qg call fzf#run({
        "\ 'source':  printf('rg --no-heading --column --color always "%s"',
        "\                   escape(empty(<q-args>) ? '^(?=.)' : <q-args>, '"\')),
        "\ 'sink*':    function('<sid>ag_handler'),
        "\ 'options': '--ansi --expect=ctrl-t,ctrl-v,ctrl-x --delimiter : --nth 1,4 '.
        "\            '--multi --bind=ctrl-a:select-all,ctrl-d:deselect-all ',
        "\ 'down':    '50%'
        "\ })
        "" \            '--color hl:68,hl+:110',
        "function! s:ag_to_qf(line)
        "  let l:parts = split(a:line, ':')
        "  return {'filename': l:parts[0], 'lnum': l:parts[1], 'col': l:parts[2],
        "        \ 'text': join(l:parts[3:], ':')}
        "endfunction
        "function! s:ag_handler(lines)
        "  if len(a:lines) < 2 | return | endif

        "  let l:cmd = get({'ctrl-x': 'split',
        "               \ 'ctrl-v': 'vertical split',
        "               \ 'ctrl-t': 'tabe'}, a:lines[0], 'e')
        "  let l:list = map(a:lines[1:], 's:ag_to_qf(v:val)')

        "  let l:first = l:list[0]
        "  execute l:cmd escape(l:first.filename, ' %#\')
        "  execute l:first.lnum
        "  execute 'normal!' l:first.col.'|zz'

        "  if len(l:list) > 1
        "    call setqflist(l:list)
        "    copen
        "    wincmd p
        "  endif
        "endfunction

    Plug 'junegunn/goyo.vim'
    " Distraction free mode. Good for coding and as well as prose writing.
      let g:goyo_width = 81
      " make vim close the First time you do :quit
      " https://github.com/junegunn/goyo.vim/wiki/Customization
      function! s:goyo_enter()
        let b:quitting = 0
        let b:quitting_bang = 0
        augroup goyo_buffer
          autocmd QuitPre <buffer> let b:quitting = 1
        augroup END
        cabbrev <buffer> q! let b:quitting_bang = 1 <bar> q!
      endfunction
      function! s:goyo_leave()
        " Quit Vim if this is the only remaining buffer
        if b:quitting && len(filter(range(1, bufnr('$')), 'buflisted(v:val)')) == 1
          if b:quitting_bang
            qa!
          else
            qa
          endif
        endif
      endfunction
      augroup goyo_stuff
        autocmd User GoyoEnter call <SID>goyo_enter()
        autocmd User GoyoLeave call <SID>goyo_leave()
      augroup END

    Plug 'junegunn/vim-journal'

    Plug 'junegunn/limelight.vim'

    Plug 'junegunn/rainbow_parentheses.vim'
    let g:rainbow#pairs = [['(', ')'], ['[', ']'], ['{', '}']]

    Plug 'junegunn/gv.vim'
    " :GV to open git view (commit browser)

    Plug 'junegunn/vader.vim'

    Plug 'junegunn/vim-easy-align'
    " Align chunks of code on a character/regex. Makes it really easy to have
    " nice formatting.

    Plug 'justinmk/vim-dirvish'
    " directory viewer
      " sort folders at top
      let g:dirvish_mode = ':sort ,^.*[\/],'
      augroup dirvish_stuff
        autocmd FileType dirvish setlocal nonumber
        autocmd FileType dirvish silent! unmap <buffer> <C-p>
      augroup END

    Plug 'leafgarland/typescript-vim'

    Plug 'markonm/traces.vim'
    " show a live preview of :substitute

    Plug 'mattn/emmet-vim'
    " Faster html entry. I currently don't use this.

    "Plug 'mxw/vim-jsx'
    " jsx syntax highlighting (conflicts with lit-html)

    Plug 'nelstrom/vim-visual-star-search'
    " Bring "*" key behavior into visual mode. Extremely useful.
    " (see ":help *").

    Plug 'othree/html5.vim'

    if !exists('g:dumb_js')
      Plug 'pangloss/vim-javascript'
      " Vastly improved syntax highlighting.
    endif
      let g:javascript_plugin_jsdoc = 1
      command! FastJS let g:dumb_js = 1 | source $MYVIMRC
      command! SlowJS unlet g:dumb_js | source $MYVIMRC

    Plug 'othree/eregex.vim'
    " Lets me use more standard regex.
      " Search with :M/[regex]
      " Substitute with <range> :S/regex/string/
      let g:eregex_default_enable = 0
      nnoremap <Leader>m/ :M/

    Plug 'ryanoasis/vim-devicons'
    " Shows pretty little icons when you use a nerdfont in your terminal.
      if hostname() =~# 'asus-zenbook'
        let g:webdevicons_enable = 0
      else
        let g:webdevicons_enable = 1
      endif
    Plug 'scrooloose/nerdtree'
    " Project tree sidebar that kind of defies the philosophy of vim

    Plug 'SirVer/ultisnips'
    " I use this for Polymer element templates.
    let g:UltiSnipsSnippetDirectories = ['~/.vim/UltiSnips', 'UltiSnips']
    " ^ workaround bug https://github.com/SirVer/ultisnips/issues/711

    if (!empty(system('command -v npm')))
      Plug 'ternjs/tern_for_vim', { 'do': 'npm install' }
    " Intelligent completion for JavaScript. It's amazing.
      let g:tern_show_signature_in_pum = 1
      set updatetime=1000
      :nnoremap <Leader>td :TernDoc<cr>
      augroup tern_stuff
        autocmd CompleteDone * pclose
      augroup END
    endif


    Plug 'terryma/vim-multiple-cursors'
    " Like Sublime's Cmd-D. Ctrl-N on a word to multiply your cursor on
    " subsequent matches for batch editing.

    Plug 'tfnico/vim-gradle'
    " Syntax highlighting

    Plug 'tomtom/tcomment_vim'
    " Toggle code comments. Mapped to Ctrl-//
      let g:tcomment#replacements_xml = {} " don't substitute weird characters when commenting html lines

    Plug 'tpope/vim-fugitive'
    Plug 'tpope/vim-rhubarb'
    " Various integrated git tools. I use this a lot.
      nnoremap <Leader>gb :Gblame -w<cr>
      nnoremap <leader>gs :Gstatus<cr>
      " http://vimcasts.org/episodes/fugitive-vim-working-with-the-git-index/
      " c-n, c-p jumps to files
      " p        runs add --patch
      " cc       runs commit
      " -        stages/unstages
      " D        diff
      nnoremap <leader>gd :Gdiff<cr>
      "          (left is index (staged), right is working)
      "          dp      diffput
      "          do      diffget (think "obtain")
      "          :w      write to index/working copy
      "          [c,]c   jump to prev/next change
      "          c-w c-o nice way to exit
      "          c-w c-w goes between columns


    Plug 'tpope/vim-rsi'
    " add readline keybindings http://readline.kablamo.org/emacs.html

    Plug 'tpope/vim-unimpaired'

    Plug 'tpope/vim-obsession'
    " :Obsession ~/.vim/obsessions/
    " :source ~/.vim/obsessions/Session.vim
    command! -bang Sesh call Sesh(<bang>0)
    function! Sesh(bang)
      let l:file = $HOME . '/.vim/obsessions/Session.vim'
      let l:isTracking = !empty(ObsessionStatus('tracking', '')) " true for both off and pused

      if (a:bang) " replace persisted session
        if (l:isTracking)
          Obsession!
        endif
        if (filereadable(l:file))
          call delete(l:file)
        endif
        exec 'Obsession ' . l:file
      else " restore session if possible or start tracking current
        if (!l:isTracking)
          if (filereadable(l:file))
            exec 'source ' . l:file
          else
            exec 'Obsession ' . l:file
          endif
        else
          echom 'already tracking'
        endif
      endif
    endfunction

    if (!empty(glob('~/Dropbox/vimwiki')))
      Plug 'vimwiki/vimwiki'
    " Quick access to a personal wiki. In vim.
      let g:vimwiki_list = [
      \   {
      \     'path': '$HOME/Dropbox/vimwiki/md',
      \     'syntax': 'markdown',
      \     'ext': '.md',
      \   },
      \   {
      \     'path': '$HOME/Dropbox/vimwiki'
      \   },
      \ ] " 'syntax': 'markdown', 'ext': '.md'}]
    endif

    Plug 'w0rp/ale'
    " Asynchronous linting of all kinds. I use this for bash scripting, fish
    " shell, vim, javascript, and more.
      let g:ale_linters = {
        \ 'html': ['eslint'],
        \ 'javascript': ['eslint'],
        \ 'java': [],
      \}
      let g:ale_linter_aliases = { 'html': ['html', 'javascript'] }
      let g:ale_echo_msg_format = '%linter%: %s (%code%)'
      let g:ale_fixers = {
            \ 'javascript': ['eslint'],
            \ 'html': ['eslint']
            \}
      :nnoremap <Leader>an :ALENextWrap<Enter>


    " Plug 'wellle/targets.vim'
    " Advanced vim text objects. Sometimes this is slow.

    Plug 'whiteinge/diffconflicts'
    " git config --global merge.tool diffconflicts
    " git config --global mergetool.diffconflicts.cmd 'vim -c DiffConflicts "$MERGED" "$BASE" "$LOCAL" "$REMOTE"'
    " git config --global mergetool.diffconflicts.trustExitCode true
    " git config --global mergetool.keepBackup false

    if (!empty(glob('~/Dropbox/vim-notes')))
      Plug 'xolox/vim-notes'
      Plug 'xolox/vim-misc'
    " Quickly write and access notes that sync to Dropbox
      let g:notes_directories = ['~/Dropbox/vim-notes']
      let g:notes_smart_quotes = 0
      let g:notes_suffix = '.txt'
      let g:notes_conceal_bold = 0
    endif

    " languages
    Plug 'posva/vim-vue'
    Plug 'dag/vim-fish'
    Plug 'vim-scripts/groovyindent-unix'

    " colorschemes
    if (has('termguicolors'))
      set termguicolors
    else
      set t_Co=256
    endif
    Plug 'NLKNguyen/papercolor-theme'
    Plug 'dracula/vim'
    Plug 'KKPMW/sacredforest-vim'
    Plug 'junegunn/seoul256.vim'
    Plug 'mhartington/oceanic-next'
    Plug 'morhetz/gruvbox'
    Plug 'nanotech/jellybeans.vim'
    Plug 'rakr/vim-one'
    Plug 'romainl/Apprentice'

    if has('mac')
      Plug 'junegunn/vim-xmark', { 'do': 'make' }
    endif

    "run :PlugInstall to install new plugins
  call plug#end()

  if (!empty(glob('~/.vim/vim-plug-extras.vim')))
    source ~/.vim/vim-plug-extras.vim
  endif

  if (hostname() ==# 'Smithers.local')
    let g:python3_host_prog='/usr/local/bin/python3'
  elseif (hostname() ==# 'zamperini4')
    let g:python3_host_prog='/usr/bin/python3'
  endif

" Key Bindings
  " insert mode shortcuts
    :inoremap <C-@> <C-Space>
    :inoremap <C-Space> <C-x><C-o>
    :inoremap jk 
    " :inoremap II <Esc>I
    " :inoremap AA <Esc>A
    :inoremap jl <Esc>:
    :imap \t <Esc>:r! date "+\%Y\%m\%d"<Enter>kJA

  " normal mode shortucts
    "insert time:
    :nnoremap <Leader>it :r! date "+\%Y\%m\%d"<Enter>kJ
    :com! InsertDate :r! date "+\%Y\%m\%d"

    :nnoremap <C-h> 5zh
    :nnoremap <C-l> 5zl
    :nnoremap Q <nop>
    :nnoremap <Leader>T :enew<cr>
    :nnoremap <Leader>bk :bnext
    :nnoremap <Leader>bj :bprevious
    let g:BASH_Ctrl_j = 'off' "this is undocumented!
    " :nmap <C-j> :bprevious\
    " :nmap <C-k> :bnext\
    :nnoremap <Leader>x :NERDTreeClose<enter>:bd
    :nnoremap <Leader>X :NERDTreeClose<enter>:bd!
    :nnoremap <Leader><Leader> :w<Enter>
    " :nmap <Leader>W :bd!\
    :nnoremap <Leader><Tab> :b#
          "most recent buffer
    :nnoremap <Leader>ss :syntax sync fromstart<enter>
    :nnoremap <Leader>BD :bufdo bd<enter>

    :let g:html_wrong_comments=1 "be lenient with html comment syntax. This is a must-have for documented Polymer code.

    map <F10> :echo map(synstack(line("."), col(".")), "synIDattr(v:val, 'name')")<cr>

    " junegunn/vim-easy-align
    :xmap ga <Plug>(EasyAlign)
    :nnoremap ga <Plug>(EasyAlign)

    " CODE COPIED FROM https://github.com/zenbro/dotfiles/blob/master/.nvimrc#L151-L187
      " If split in given direction exists - jump, else create new split
      function! JumpOrOpenNewSplit(key, cmd, fzf) " {{{
        let l:current_window = winnr()
        execute 'wincmd' a:key
        if l:current_window == winnr()
          execute a:cmd
          if a:fzf
            Files
          else
            Dirvish %:p:h
          endif
        else
          if a:fzf
            Files
          endif
        endif
      endfunction " }}}
      nnoremap <silent> <Leader>hh :call JumpOrOpenNewSplit('h', ':leftabove vsplit', 0)<CR>
      nnoremap <silent> <Leader>ll :call JumpOrOpenNewSplit('l', ':rightbelow vsplit', 0)<CR>
      nnoremap <silent> <Leader>kk :call JumpOrOpenNewSplit('k', ':leftabove split', 0)<CR>
      nnoremap <silent> <Leader>jj :call JumpOrOpenNewSplit('j', ':rightbelow split', 0)<CR>
      " Same as above, except it opens unite at the end
      nnoremap <silent> <Leader>h<Space> :call JumpOrOpenNewSplit('h', ':leftabove vsplit', 1)<CR>
      nnoremap <silent> <Leader>l<Space> :call JumpOrOpenNewSplit('l', ':rightbelow vsplit', 1)<CR>
      nnoremap <silent> <Leader>k<Space> :call JumpOrOpenNewSplit('k', ':leftabove split', 1)<CR>
      nnoremap <silent> <Leader>j<Space> :call JumpOrOpenNewSplit('j', ':rightbelow split', 1)<CR>
      " Delete all hidden buffers
      nnoremap <silent> <Leader><BS>b :call DeleteHiddenBuffers()<CR>
      function! DeleteHiddenBuffers() " {{{
        let l:tpbl=[]
        call map(range(1, tabpagenr('$')), 'extend(l:tpbl, tabpagebuflist(v:val))')
        for l:buf in filter(range(1, bufnr('$')), 'bufexists(v:val) && index(l:tpbl, v:val)==-1')
          silent execute 'bwipeout' l:buf
        endfor
      endfunction " }}}

    " THIS DOES NOT WORK
    func! FishCantEven(str)
      set shell /usr/bin/fish
      echom a:str
      :exec '!'.a:str
      " echo a:000
      " set shell /bin/bash
    endfunc
    :com! -nargs=1 FishCantEven call FishCantEven(<args>)

    command! FormatJSON :%!python -m json.tool

    if has('nvim')
      tmap <C-u> <C-k><C-k><C-k><C-k><C-k><C-k><C-k><C-k><C-k><C-k><C-k><C-k><C-k>
      tmap <C-d> <C-j><C-j><C-j><C-j><C-j><C-j><C-j><C-j><C-j><C-j><C-j><C-j><C-j>
    endif

    " nerdtree stuff
    :nnoremap <Leader>tt :NERDTreeToggle
    :nnoremap <Leader>tf :NERDTreeFind
    " close nerdtree if it's the only remaining buffer
    autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif

  " terminal mode shortcuts
    if has('nvim')
      :tnoremap <C-w> <C-\><C-n><C-w>
      " conflicts with FZF
      " :tmap <C-j> <C-\><C-n>:bprevious<Enter>
      " :tmap <C-k> <C-\><C-n>:bnext<Enter>
    endif

" Miscellanious commands
  com! JA exec "cd /Users/smithers/git/estatfstat/"
  com! JAJ exec "cd /Users/smithers/git/estatfstat/airstat/src/main/web/"
  com! JV exec "edit /Users/smithers/.vim/plugged"

  nnoremap <leader>; :

  " open current file in VSCode (and jump to cursor location)
  :command! OpenInVSCode exe "silent !code --goto '" . expand("%") . ":" . line(".") . ":" . col(".") . "'" | redraw!
  :command! OpenCwdInVSCode exe "silent !code '" . getcwd() . "' --goto '" . expand("%") . ":" . line(".") . ":" . col(".") . "'" | redraw!
  :command! Idea exe "silent !idea '" . getcwd() . "' '" . expand("%") . ":" . line(".") . "'" | redraw! | quit

  " open url on current line
  func! OpenUrl()
    exec 'silent !python -mwebbrowser "'.(fnameescape(matchstr (getline('.'), 'https\?://[a-zA-Z0-9\./\-?=\&+@,!:_#]\+[^,.) \"]'))).'" 2> /dev/null > /dev/null' | redraw!
  endfu
  com! TestUrl exec 'echom            "'.(fnameescape(matchstr (getline('.'), 'https\?://[a-zA-Z0-9\./\-?=\&+@,!:_#]\+[^,.) \"]'))).'"'
  nnoremap <Leader>ou :call OpenUrl()<Enter>
  " toggle plugins and syntax to make vim really fast
  " com! Fast :GitGutterToggle | :ALEToggle | :if exists("g:syntax_on") | syntax off | else | syntax enable | endif
  com! Fast :ALEDisable | syntax off
  com! Slow :ALEEnable  | syntax on

  " https://github.com/mhinz/vim-galore#saner-behavior-of-n-and-n
  nnoremap <expr> n  'Nn'[v:searchforward]
  nnoremap <expr> N  'nN'[v:searchforward]
  " https://github.com/mhinz/vim-galore#saner-command-line-history
  cnoremap <c-n>  <down>
  cnoremap <c-p>  <up>
  " Saner CTRL L: https://github.com/mhinz/vim-galore#saner-ctrl-l
  nnoremap <leader>l :nohlsearch<cr>:diffupdate<cr>:syntax sync fromstart<cr><c-l>
  " Quickly Move Current Line: https://github.com/mhinz/vim-galore#matchit
  nnoremap [e  :<c-u>execute 'move -1-'. v:count1<cr>
  nnoremap ]e  :<c-u>execute 'move +'. v:count1<cr>
  " Quickly Add Empty Lines: https://github.com/mhinz/vim-galore#quickly-add-empty-lines
  nnoremap [<space>  :<c-u>put! =repeat(nr2char(10), v:count1)<cr>'[
  nnoremap ]<space>  :<c-u>put =repeat(nr2char(10), v:count1)<cr>
  " Quickly Edit Your Macros:  https://github.com/mhinz/vim-galore#quickly-edit-your-macros
  nnoremap <leader>m  :<c-u><c-r><c-r>='let @'. v:register .' = '. string(getreg(v:register))<cr><c-f><left>
  " Change Cursor Style Dependent On Mode: https://github.com/mhinz/vim-galore#change-cursor-style-dependent-on-mode
  if empty($TMUX)
    if (s:os ==? 'Linux')
      augroup curshapestuff
        au VimEnter,InsertLeave * silent execute '!echo -ne "\e[2 q"' | redraw!
        au InsertEnter,InsertChange *
              \ if v:insertmode == 'i' | 
              \   silent execute '!echo -ne "\e[6 q"' |
              \ elseif v:insertmode == 'r' |
              \   silent execute '!echo -ne "\e[4 q"' |
              \ endif
        au VimLeave * silent execute '!echo -ne "\e[ q"' |
      augroup END
    elseif (s:os ==? 'Darwin')
      let &t_SI = "\<Esc>]50;CursorShape=1\x7"
      let &t_EI = "\<Esc>]50;CursorShape=0\x7"
      let &t_SR = "\<Esc>]50;CursorShape=2\x7"
    endif
  else
    let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
    let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
    let &t_SR = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=2\x7\<Esc>\\"
  endif

" Viewer
  func! Reader()
      :AnsiEsc
      set laststatus=0
      set nonumber
  endfu

" Experimental scroll mode
  nnoremap zs 0zz:call dotfile_extras#ToggleScrollMode()<Enter>

" Prose
  set nojoinspaces  " prevent vim from inserting 2 spaces after periods.
  com! ProseMode    call dotfile_extras#ProseMode()
  com! CodeMode     call dotfile_extras#CodeMode()
  com! SoftWrapMode call dotfile_extras#SoftWrappedProcessorMode()
  nnoremap <F4>    :call dotfile_extras#ToggleTerm()<CR>


  map <F6> :let $VIM_DIR=expand('%:p:h')<CR>:terminal<CR>cd $VIM_DIR<CR>clear<CR>

"# GUI Customization
  if has('gui_running')
    set background=dark
    set autoread        "auto-load changes from disk
    if (s:os ==? 'Darwin')
      set guifont=Monaco:h12
    endif

    :set guioptions-=m  "remove menu bar
    :set guioptions-=T  "remove toolbar
    :set guioptions-=r  "remove right-hand scroll bar
    :set guioptions-=L  "remove left-hand scroll bar
  endif

" Rare Tools
  func! HighlightTrailingSpace()
    highlight TrailingSpace ctermbg=red ctermfg=white guibg=#592929
    match TrailingSpace /\s\+\n/
  endfu
  command! TrailingSpaceHighlight call HighlightTrailingSpace()
  command! TrailingSpaceDeleteAll :%s/\s\+\n//gc

  " call clearmatches() " http://vim.wikia.com/wiki/Highlight_long_lines
  func! HighlightOverlength()
    highlight OverLength ctermbg=red ctermfg=white guibg=#592929
    match OverLength /\%81v.\+/
  endfu
  func! SetWidthEightyFour()
    :vertical resize 84
  endfu

" Basics
  com! FormatBullets setlocal flp=^\\s*\\(-\\\\|\\d\\+\\.\\)\\s* " I want to autoindent paragraphs that start with "- " or "123. "
  if filereadable($VIMRUNTIME . '/defaults.vim')
    source $VIMRUNTIME/defaults.vim " new in vim 8
    packadd! matchit " bundled default plugin
  else
    set wildmenu      "show suggestions for vim commands
    set incsearch     "incremental search (something else also turns this on)
    syntax enable
    set mouse=a       " default in Vim 8 defaults.vim
    set backspace=indent,eol,start
    set history=200		" keep 200 lines of command line history
  endif
  set ttimeoutlen=0 "timeout instantly when pressing esc during visual mode
  set foldmethod=syntax
  set foldlevelstart=99
  set nowrap
  set ignorecase    "search ignores case
  set smartcase     "unless there's a capital letter
  set number
  set autoindent
  set smartindent
  set hlsearch      " default in NeoVim

  set splitbelow    " more natural split behavior
  set splitright    " more natural split behavior

  set hidden        " leave buffers without saving

  set completeopt=menuone,longest,preview " make completion menu awesome
  set directory=~/.config/vimswap,.

  set sessionoptions-=options " for some reason, vim won't restore with syntax highlighting without this. https://stackoverflow.com/questions/9281438/syntax-highlighting-doesnt-work-after-restore-a-previous-vim-session

  " disable audible and visual bells set noerrorbells https://github.com/mhinz/vim-galore#disable-audible-and-visual-bells
  "set noerrorbells "this does not work
  "set novisualbell
  "set t_vb=
  set belloff=all

  :cabbrev h vert h
                    " execute [:h QUERY] to open help page in vertical split buffer

  if !&scrolloff
    set scrolloff=3 " Show next 3 lines while scrolling.
  endif
  if !&sidescrolloff
    set sidescrolloff=5 " Show next 5 columns while side-scrolling.
  endif
  "(source: http://nerditya.com/code/guide-to-neovim/)

" Tabs
  set expandtab     " SPACES over TABS
  set smarttab      " delete multiple spaces at once (as if deleting a tab character)
  com! -nargs=1 Tab      set      tabstop=<args> | set      shiftwidth=<args> "| set softtabstop=<args>
  com! -nargs=1 LocalTab setlocal tabstop=<args> | setlocal shiftwidth=<args> "| set softtabstop=<args>
  " if (hostname() == "Smithers.local")
  "   :Tab 4
  " elseif (hostname() == "zamperini2")
  "   :Tab 2
  " elseif (hostname() == "zamperini4")
  "   :Tab 2
  " endif

  " autocmd Filetype vimrc setlocal expandtab tabstop=2 shiftwidth=2 softtabstop=2

  " func! JSFormatting()
  "   autocmd FileType javascript setlocal equalprg=js-beautify\ --stdin
  " endfu

" Theme shortcuts
  com! Default    set background=dark  | colorscheme default
  com! DarkGruv   set background=dark  | colorscheme gruvbox
  com! DarkOcean  set background=dark  | colorscheme OceanicNext
  com! DarkPaper  set background=dark  | colorscheme PaperColor
  com! DarkOne    set background=dark  | colorscheme one
  com! DarkSeoul  set background=dark  | colorscheme seoul256
  com! DarkSacredForest                  colorscheme sacredforest
  com! DarkApprentice                    colorscheme apprentice
  com! LightOne   set background=light | colorscheme one
  com! LightGruv  set background=light | colorscheme gruvbox
  com! LightOcean set background=light | colorscheme OceanicNextLight
  com! LightPaper set background=light | colorscheme PaperColor
  com! LightSeoul set background=light | colorscheme seoul256

  augroup colorschemespellingfix
    autocmd!
    autocmd ColorScheme * highlight SpellBad term=reverse ctermbg=224 gui=undercurl guisp=Yellow guibg=Red
    " ^ termguicolors relies on undercurl for misspellings, but many
    " terminals don't have that.
  augroup END

  if has('nvim')
    let $NVIM_TUI_ENABLE_TRUE_COLOR=1
    :DarkGruv
    set nofixeol      " don't insert EOL at end of file
  else
    colorscheme apprentice
  end

" simple session restoration http://vim.wikia.com/wiki/Go_away_and_come_back
  function! MakeSession()
    let b:sessiondir = $HOME . '/.vim/sessions' . getcwd()
    if (filewritable(b:sessiondir) != 2)
      exe 'silent !mkdir -p ' b:sessiondir
      redraw!
    endif
    let b:filename = b:sessiondir . '/session.vim'
    exe 'mksession! ' . b:filename
  endfunction

  function! LoadSession()
    let b:sessiondir = $HOME . '/.vim/sessions' . getcwd()
    let b:sessionfile = b:sessiondir . '/session.vim'
    if (filereadable(b:sessionfile))
      exe 'source ' b:sessionfile
    else
      echo 'No session loaded.'
    endif
  endfunction
  " au VimEnter * nested if argc() == 0 | :call LoadSession() | endif
  augroup session_saving
    au VimLeave * :call MakeSession()
  augroup END
  com! LoadSession call LoadSession()

" Auto Commands
  augroup vimrc_autocomamnds
    autocmd!

    " custom filetype behaviors
    autocmd FileType gitcommit setlocal spell
    autocmd FileType gitcommit startinsert!
    autocmd FileType text     setlocal spell
    autocmd Filetype markdown setlocal spell

    if (v:version >= 810)
      autocmd TerminalOpen * setlocal nonumber norelativenumber
    endif

    " auto-reload vimrc whenever I save it
    autocmd BufWritePost vimrc,.vimrc, source $MYVIMRC | call lightline#disable() | call lightline#enable()
    "                                                       "  ^ not entirely sure why all this craziness is necessary. It was necessary with Airline too!

    " disable syntax when editing huge files so vim stays snappy
    autocmd Filetype * if (getfsize(@%) > 500000) | setlocal syntax=OFF | endif
    " auto detect indent for bower component files
    autocmd Filetype * if (IsBowerComponent()) | :DetectIndent | endif

    " code execution
    autocmd Filetype python     nnoremap <buffer> <space>py :!python %<cr>
    "autocmd Filetype javascript nnoremap <buffer> <space>js :!node %<cr>
    " autocmd Filetype javascript nnoremap <buffer> <space>js :ter ++rows=10 node %<cr>k
    autocmd Filetype javascript nnoremap <buffer> <space>js o:call RunNodeTerm()<cr>h
    autocmd Filetype javascript,html call MakeJSKeys()
    autocmd Filetype notes :command!-buffer MarkdownThing call OpenMarkdown()
    function! OpenMarkdown()
      silent !Markdown.pl % > deleteme.html; open deleteme.html
      redraw!
    endfunction

  augroup END

  function! RunNodeTerm()
    call term_start('node ' . expand('%'), { 'vertical': 1, 'term_cols': 80, 'norestore': 1 })
  endfunction
  function! MakeJSKeys()
    :nnoremap <buffer> <Leader>il oconsole.log();F)i
    :nnoremap <buffer> <Leader>iL oconsole.log('%c', 'font-size:15px');F,hi
    :nnoremap <buffer> <Leader>liw yiwoconsole.log('0', 0);<Esc>
    :nnoremap <buffer> <Leader>lif yiwoconsole.log('0()');<Esc>
    :nnoremap <buffer> <Leader>liF yiwoconsole.log('%c0()', 'font-size:15px');<Esc>^2w
    :nnoremap <buffer> <Leader>gif yiwf{oconsole.group('0');<Esc>]}Oconsole.groupEnd();<Esc>^
  endfunction

  function! IsBowerComponent()
    return @% =~# 'bower_components'
  endfunction

  " lil debugging util
  com! -nargs=1 Log execute 'silent! ! echo ' . fnameescape(<args>) . ' >> VIM_LOG'
let s:vimrcIsExecuting = 0
