" Note: NeoVim's html-embedded-javascript indentation is isn't smart like Vim
" 8's. It needs to be updated. Until then, you can fix it by running this
" command:
" curl https://raw.githubusercontent.com/vim/vim/master/runtime/indent/html.vim > ~/.vim/plugged/vim-javascript/indent/html.vim

let s:vimrcIsExecuting = 1
:let mapleader = " "

" Install vim-plug
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
    \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif

" VIM PLUG
  call plug#begin('~/.vim/plugged')

    Plug 'airblade/vim-gitgutter'
    " Show indicators for what's been modified/added/deleted.

    Plug 'alvan/vim-closetag'
    " Automatically close html tags.

    Plug 'ciaranm/detectindent'
    " Analyze current buffer and configure tabbing to match.

    Plug 'chrisbra/Colorizer'
    " Show hex colors by running :ColorHighlight or :ColorToggle

    Plug 'editorconfig/editorconfig-vim'
    " Configure different coding styles on a per-project basis and have vim
    " automatically adjust. There are equivalent plugins for all major code
    " editors. It's great. In a better world, every project would have a
    " .editorconfig file at its root.

    Plug 'itchyny/lightline.vim'
    " inspired by https://statico.github.io/vim3.html#lightline-powerline-airline-and-status-bars
      set laststatus=2 "always show airline, instead of only after splitview
      set t_Co=256     "help airline show colors
      set noshowmode   "lightline will show mode for me
      set showcmd      "shows size of visual selection BELOW lightline
      let g:lightline = {
      \   'active': {
      \     'left': [['mode', 'paste'], ['filename', 'modified'], ['git_changes']],
      \     'right': [['lineinfo'], ['percent'], ['readonly', 'linter_warnings', 'linter_errors', 'linter_ok']]
      \   },
      \   'component_expand': {
      \     'git_changes': 'LightLineChanges',
      \     'linter_warnings': 'LightlineLinterWarnings',
      \     'linter_errors': 'LightlineLinterErrors',
      \     'linter_ok': 'LightlineLinterOK'
      \   },
      \   'component_type': {
      \     'readonly': 'error',
      \     'linter_warnings': 'warning',
      \     'linter_errors': 'error'
      \   },
      \   'separator': {
      \     'left': '',
      \     'right': ''
      \   },
      \   'enable': {
      \     'statusline': 1,
      \     'tabline': 0
      \   }
      \ }
      " let g:lightline.separator.right = ''
      " let g:lightline.separator.left =  ''
      function! LightLineChanges()
        if exists('*GitGutterGetHunkSummary')
          let [ added, modified, removed ] = GitGutterGetHunkSummary()
          let l:total = (added + modified + removed)
          let output = ''
          if (added != 0)
            let output .= printf('+%d ', added)
          endif
          if (modified != 0)
            let output .= printf('~%d ', modified)
          endif
          if (removed != 0)
            let output .= printf('-%d ', removed)
          endif
          return output
        endif
      endfunction
      function! LightlineLinterWarnings() abort
        let l:counts = ale#statusline#Count(bufnr(''))
        let l:all_errors = l:counts.error + l:counts.style_error
        let l:all_non_errors = l:counts.total - l:all_errors
        return l:counts.total == 0 ? '' : printf('%d ▲', all_non_errors)
      endfunction
      function! LightlineLinterErrors() abort
        let l:counts = ale#statusline#Count(bufnr(''))
        let l:all_errors = l:counts.error + l:counts.style_error
        let l:all_non_errors = l:counts.total - l:all_errors
        return l:counts.total == 0 ? '' : printf('%d ✗', all_errors)
      endfunction
      function! LightlineLinterOK() abort
        let l:counts = ale#statusline#Count(bufnr(''))
        let l:all_errors = l:counts.error + l:counts.style_error
        let l:all_non_errors = l:counts.total - l:all_errors
        return l:counts.total == 0 ? '✓' : ''
      endfunction
      autocmd User ALELint call s:MaybeUpdateLightline()
      function! s:MaybeUpdateLightline()
        " Update and show lightline but only if it's visible (e.g., not in Goyo)
        if exists('#lightline')
          call lightline#update()
        end
      endfunction

    Plug 'jeetsukumaran/vim-filebeagle'
    " Super-minimal file explorer accessible through the '-' key.

    Plug 'jeetsukumaran/vim-indentwise'
    " Navigation based on indentation. I currently don't use this.

    Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
    Plug 'junegunn/fzf.vim'
    " Incredible fuzzy search for all sorts of things. Best plugin ever.

      " ag-results in quickfix (https://github.com/junegunn/fzf/wiki/Examples-(vim)#narrow-ag-results-within-vim)
        command! -nargs=* Qg call fzf#run({
        \ 'source':  printf('ag --nogroup --column --color "%s"',
        \                   escape(empty(<q-args>) ? '^(?=.)' : <q-args>, '"\')),
        \ 'sink*':    function('<sid>ag_handler'),
        \ 'options': '--ansi --expect=ctrl-t,ctrl-v,ctrl-x --delimiter : --nth 4.. '.
        \            '--multi --bind=ctrl-a:select-all,ctrl-d:deselect-all '.
        \            '--color hl:68,hl+:110',
        \ 'down':    '50%'
        \ })
        function! s:ag_to_qf(line)
          let parts = split(a:line, ':')
          return {'filename': parts[0], 'lnum': parts[1], 'col': parts[2],
                \ 'text': join(parts[3:], ':')}
        endfunction
        function! s:ag_handler(lines)
          if len(a:lines) < 2 | return | endif

          let cmd = get({'ctrl-x': 'split',
                       \ 'ctrl-v': 'vertical split',
                       \ 'ctrl-t': 'tabe'}, a:lines[0], 'e')
          let list = map(a:lines[1:], 's:ag_to_qf(v:val)')

          let first = list[0]
          execute cmd escape(first.filename, ' %#\')
          execute first.lnum
          execute 'normal!' first.col.'|zz'

          if len(list) > 1
            call setqflist(list)
            copen
            wincmd p
          endif
        endfunction

    Plug 'junegunn/goyo.vim'
    " Distraction free mode. Good for coding and as well as prose writing.
      let g:goyo_width = 81
      " make vim close the First time you do :quit
      " https://github.com/junegunn/goyo.vim/wiki/Customization
      function! s:goyo_enter()
        let b:quitting = 0
        let b:quitting_bang = 0
        autocmd QuitPre <buffer> let b:quitting = 1
        cabbrev <buffer> q! let b:quitting_bang = 1 <bar> q!
      endfunction
      function! s:goyo_leave()
        " Quit Vim if this is the only remaining buffer
        if b:quitting && len(filter(range(1, bufnr('$')), 'buflisted(v:val)')) == 1
          if b:quitting_bang
            qa!
          else
            qa
          endif
        endif
      endfunction
      autocmd User GoyoEnter call <SID>goyo_enter()
      autocmd User GoyoLeave call <SID>goyo_leave()

    Plug 'junegunn/limelight.vim'

    Plug 'junegunn/rainbow_parentheses.vim'
    let g:rainbow#pairs = [['(', ')'], ['[', ']'], ['{', '}']]

    Plug 'junegunn/vim-easy-align'
    " Align chunks of code on a character/regex. Makes it really easy to have
    " nice formatting.

    Plug 'mattn/emmet-vim'
    " Faster html entry. I currently don't use this.

    Plug 'mtth/scratch.vim'
    " Press "gs" to type in a hideaway scratch buffer

    Plug 'nelstrom/vim-visual-star-search'
    " Bring "*" key behavior into visual mode. Extremely useful.
    " (see ":help *").

    Plug 'pangloss/vim-javascript'
    " Vastly improved syntax highlighting.
      let g:javascript_plugin_jsdoc = 1

    Plug 'othree/eregex.vim'
    " Lets me use more standard regex
      let g:eregex_default_enable = 0

    Plug 'ryanoasis/vim-devicons'
    " Shows pretty little icons when you use a nerdfont in your terminal.
      let g:webdevicons_enable = 1

    Plug 'scrooloose/nerdtree'
    " Project tree sidebar that kind of defies the philosophy of vim

    Plug 'SirVer/ultisnips'
    " I use this for Polymer element templates.
    let g:UltiSnipsSnippetDirectories = ['~/.vim/UltiSnips', 'UltiSnips']
    " ^ workaround bug https://github.com/SirVer/ultisnips/issues/711

    Plug 'ternjs/tern_for_vim', { 'do': 'npm install' }
    " Intelligent completion for JavaScript. It's amazing.
      let tern_show_signature_in_pum          = 1
      set updatetime=1000
      :nmap <Leader>td :TernDoc<cr>
      :autocmd CompleteDone * pclose


    Plug 'terryma/vim-multiple-cursors'
    " Like Sublime's Cmd-D. Ctrl-N on a word to multiply your cursor on
    " subsequent matches for batch editing.

    Plug 'tfnico/vim-gradle'
    " Syntax highlighting

    Plug 'tomtom/tcomment_vim'
    " Toggle code comments. Mapped to Ctrl-/

    Plug 'tpope/vim-fugitive'
    Plug 'tpope/vim-rhubarb'
    Plug 'tpope/vim-unimpaired'
    " Various integrated git tools. I use this a lot. I only use use the
    " unimpaired plugin with fugitive's ":Glog" command.

    Plug 'tpope/vim-rsi'
    " add readline keybindings http://readline.kablamo.org/emacs.html

    Plug 'vimwiki/vimwiki'
    " Quick access to a personal wiki. In vim.
    let g:vimwiki_list = [{'path': '$HOME/Dropbox/vimwiki'}] " 'syntax': 'markdown', 'ext': '.md'}]

    Plug 'w0rp/ale'
    " Asynchronous linting of all kinds. I use this for bash scripting, fish
    " shell, vim, javascript, and more.
      let g:ale_linters = {
        \ 'html': ['eslint'],
        \ 'javascript': ['eslint'],
        \ 'java': [],
      \}
      let g:ale_linter_aliases = { 'html': ['html', 'javascript'] }
      let g:ale_echo_msg_format = '(%linter%) %s'
      :nmap <Leader>an :ALENextWrap<Enter>


    " Plug 'wellle/targets.vim'
    " Advanced vim text objects. Sometimes this is slow.

    Plug 'xolox/vim-notes'
    Plug 'xolox/vim-misc'
    " Quickly write and access notes that sync to Dropbox
      let g:notes_directories = ['~/Dropbox/vim-notes']
      let g:notes_smart_quotes = 0
      let g:notes_suffix = ".txt"
      let g:notes_conceal_bold = 0

    " languages
    Plug 'posva/vim-vue'
    Plug 'dag/vim-fish'

    " colorschemes
    Plug 'junegunn/seoul256.vim'
    Plug 'mhartington/oceanic-next'
    Plug 'morhetz/gruvbox'
    Plug 'nanotech/jellybeans.vim'
    Plug 'NLKNguyen/papercolor-theme'
    Plug 'rakr/vim-one'

    if has('mac')
      Plug 'junegunn/vim-xmark', { 'do': 'make' }
    endif

    "run :PlugInstall to install new plugins
  call plug#end()

  if (hostname() == "Smithers.local")
    let g:python3_host_prog='/usr/local/bin/python3'
  elseif (hostname() == "zamperini4")
    let g:python3_host_prog='/usr/bin/python3'
  endif

" Key Bindings
  " insert mode shortcuts
    :imap <C-@> <C-Space>
    :imap <C-Space> <C-x><C-o>
    :imap jk 
    " :inoremap II <Esc>I
    " :inoremap AA <Esc>A
    :inoremap jl <Esc>:
    :imap \t <Esc>:r! date "+\%Y\%m\%d"<Enter>kJA

  " normal mode shortucts
    "insert time:
    :nmap <Leader>it :r! date "+\%Y\%m\%d"<Enter>kJ
    :com! InsertDate :r! date "+\%Y\%m\%d"

    "search for word in working directory
    :nmap <Leader>sw :Rg 
    :vmap <Leader>s  y:Rg "<Enter>

    :command! -bang -nargs=* Rg  call fzf#vim#grep('rg --column --line-number --no-heading --color=always               '.shellescape(<q-args>).'| tr -d "\017"', 1, <bang>0)
    :command! -bang -nargs=* Rgi call fzf#vim#grep('rg --column --line-number --no-heading --color=always --ignore-case '.shellescape(<q-args>).'| tr -d "\017"', 1, <bang>0)

    :nmap <C-h> 2zh
    :nmap <C-l> 2zl
    :nnoremap Q <nop>
    :nmap <Leader>T :enew<cr>
    :nmap <Leader>bk :bnext
    :nmap <Leader>bj :bprevious
    let g:BASH_Ctrl_j = 'off' "this is undocumented!
    " :nmap <C-j> :bprevious\
    " :nmap <C-k> :bnext\
    :nmap <Leader>x :NERDTreeClose<enter>:bd
    :nmap <Leader>X :NERDTreeClose<enter>:bd!
    :nmap <Leader><Leader> :w<Enter>
    " :nmap <Leader>W :bd!\
    :nmap <Leader><Tab> :b#
          "most recent buffer
    :nmap <Leader>ss :syntax sync fromstart<enter>
    :nmap <Leader>BD :bufdo bd<enter>
    :nmap <C-b>     :Buffers<enter>
    :nmap <Leader>; :Buffers<enter>
    :nmap <C-k> :Buffers<enter>

    :let html_wrong_comments=1 "be lenient with html comment syntax. This is a must-have for documented Polymer code.

    " syntax debugging (JIC)?
    map <F10> :echo "syntax debugger: <" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<'
          \ . synIDattr(synID(line("."),col("."),0),"name") . "> lo<"
          \ . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>

    " junegunn/vim-easy-align
    :xmap ga <Plug>(EasyAlign)
    :nmap ga <Plug>(EasyAlign)

    " junegunn/fzf.vim
    inoremap <expr> <c-x><c-f> fzf#vim#complete#path(
          \ "find . -path '*/\.*' -prune -o -print \| sed '1d;s:^..::'",
          \ fzf#wrap({'dir': expand('%:p:h')}))

    " CODE COPIED FROM https://github.com/zenbro/dotfiles/blob/master/.nvimrc#L151-L187
      " If split in given direction exists - jump, else create new split
      function! JumpOrOpenNewSplit(key, cmd, fzf) " {{{
        let current_window = winnr()
        execute 'wincmd' a:key
        if current_window == winnr()
          execute a:cmd
          if a:fzf
            Files
          endif
        else
          if a:fzf
            Files
          endif
        endif
      endfunction " }}}
      nnoremap <silent> <Leader>hh :call JumpOrOpenNewSplit('h', ':leftabove vsplit', 0)<CR>
      nnoremap <silent> <Leader>ll :call JumpOrOpenNewSplit('l', ':rightbelow vsplit', 0)<CR>
      nnoremap <silent> <Leader>kk :call JumpOrOpenNewSplit('k', ':leftabove split', 0)<CR>
      nnoremap <silent> <Leader>jj :call JumpOrOpenNewSplit('j', ':rightbelow split', 0)<CR>
      " Same as above, except it opens unite at the end
      nnoremap <silent> <Leader>h<Space> :call JumpOrOpenNewSplit('h', ':leftabove vsplit', 1)<CR>
      nnoremap <silent> <Leader>l<Space> :call JumpOrOpenNewSplit('l', ':rightbelow vsplit', 1)<CR>
      nnoremap <silent> <Leader>k<Space> :call JumpOrOpenNewSplit('k', ':leftabove split', 1)<CR>
      nnoremap <silent> <Leader>j<Space> :call JumpOrOpenNewSplit('j', ':rightbelow split', 1)<CR>
      " Delete all hidden buffers
      nnoremap <silent> <Leader><BS>b :call DeleteHiddenBuffers()<CR>
      function! DeleteHiddenBuffers() " {{{
        let tpbl=[]
        call map(range(1, tabpagenr('$')), 'extend(tpbl, tabpagebuflist(v:val))')
        for buf in filter(range(1, bufnr('$')), 'bufexists(v:val) && index(tpbl, v:val)==-1')
          silent execute 'bwipeout' buf
        endfor
      endfunction " }}}


    " set bash as shell so <C-X><C-F> file completion works
    " - ALSO, NeoVim async jobs return data with a prepended "[1 q" for
    "   someone unfathomable reason. That's no good.
    if (hostname() == "Smithers.local")
      :set shell=/usr/local/bin/bash "
    elseif (hostname() == "zamperini4")
      :set shell=/bin/bash "
    endif

    " THIS DOES NOT WORK
    func! FishCantEven(str)
      set shell /usr/bin/fish
      echom a:str
      :exec '!'.a:str
      " echo a:000
      " set shell /bin/bash
    endfunc
    :com! -nargs=1 FishCantEven call FishCantEven(<args>)

    :nmap <C-p> :Files<enter>
    :nmap <Leader>or :History
    " ^ open recent file
    :nmap <Leader>/ :History/
    :nmap <Leader><C-r> :History:
    " call histdel("cmd", "regexp") to delete mistaken history items
    :nmap <Leader>f~ :FZF ~
    :nmap <Leader>ft :Filetypes<enter>
    command! -bang -nargs=* Rg
                \ call fzf#vim#grep(
                \   'rg --column --line-number --no-heading --color=always '.shellescape(<q-args>), 1,
                \   <bang>0 ? fzf#vim#with_preview('up:60%')
                \           : fzf#vim#with_preview('right:50%:hidden', '?'),
                \   <bang>0)
    command! FormatJSON :%!python -m json.tool

    if has('nvim')
      tmap <C-u> <C-k><C-k><C-k><C-k><C-k><C-k><C-k><C-k><C-k><C-k><C-k><C-k><C-k>
      tmap <C-d> <C-j><C-j><C-j><C-j><C-j><C-j><C-j><C-j><C-j><C-j><C-j><C-j><C-j>
    endif

    " nerdtree stuff
    :nmap <Leader>tt :NERDTreeToggle
    :nmap <Leader>tf :NERDTreeFind
    " close nerdtree if it's the only remaining buffer
    autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif

    " git stuff
    :nmap <Leader>gb :Gblame -w<Enter>

    " GitGutter stuff
    :nmap <Leader>ga :GitGutterStageHunk<Enter>
    :nmap <Leader>gH :GitGutterLineHighlightsToggle<Enter>
    :nmap <Leader>gn :GitGutterNextHunk<Enter>
    :nmap <Leader>gN :GitGutterPrevHunk<Enter>
    :nmap <Leader>gP :GitGutterPreviewHunk<Enter>
    :nmap <Leader>gu :GitGutterUndoHunk<Enter>

  " terminal mode shortcuts
    if has('nvim')
      :tnoremap <C-w> <C-\><C-n><C-w>
      " conflicts with FZF
      " :tmap <C-j> <C-\><C-n>:bprevious<Enter>
      " :tmap <C-k> <C-\><C-n>:bnext<Enter>
    endif

" Miscellanious commands
  com! JJ exec "cd /Users/smithers/git/UC2/uc2-app/uc2/src/main/web/"
  com! JU exec "cd /Users/smithers/git/UC2/uc2-app/"
  com! JA exec "cd /Users/smithers/git/estatfstat/"
  com! JAJ exec "cd /Users/smithers/git/estatfstat/airstat/src/main/web/"
  com! Uc2js exec "cd /Users/smithers/git/UC2/uc2-app/uc2/src/main/web/"
  com! Uc2 exec "cd /Users/smithers/git/UC2/uc2-app/"
  com! JL exec "cd /home/smithers/git/lambda"
  com! JM exec "cd /home/smithers/git/mailman"
  com! JT exec "cd /home/smithers/git/TourApp/app"

  " open current file in VSCode (and jump to cursor location)
  com! VSCode exe "silent !code --goto %:" . line(".") . ":" . col(".") | redraw!

  " open url on current line
  com! OpenUrl exec "silent !python -mwebbrowser \"".(matchstr (getline("."), "https\\?://[a-zA-Z0-9\./\\-?=\\&+@,!:_#]\\+[^.) ]"))."\"" | redraw!
  com! TestUrl exec "echom                       \"".(matchstr (getline("."), "https\\?://[a-zA-Z0-9\./\\-?=\\&+@,!:_#]\\+[^.) ]"))."\""
  " toggle plugins and syntax to make vim really fast
  com! Fast :GitGutterToggle | :ALEToggle | :if exists("g:syntax_on") | syntax off | else | syntax enable | endif

" Viewer
  func! Reader()
      :AnsiEsc
      let g:airline#extensions#tabline#enabled = 0
      set laststatus=0
      set nonu
  endfu

" Experimental scroll mode
  nmap zs 0zz:call ToggleScrollMode()<Enter>
  function! ToggleScrollMode()
    if exists("s:scroll_mode")
      unmap k
      unmap j
      unmap d
      unmap u
      unlet s:scroll_mode
      echom "scroll mode off"
    else
      nnoremap j <C-e>j
      nnoremap k <C-y>k
      nnoremap d <C-d>
      nnoremap u <C-u>
      let s:scroll_mode = 1
      echom "scroll mode on"
    endif
  endfunction


" Prose
  set nojoinspaces  " prevent vim from inserting 2 spaces after periods.
  func! ProseMode()
    Goyo
    setlocal spell
    setlocal noci nosi noai nolist noshowmode noshowcmd
    setlocal complete+=s " complete from thesaurus
    LightOne " setlocal bg=light
    setlocal fo=an
    setlocal whichwrap+=h,l
    setlocal sidescrolloff=0
  endfu
  com! ProseMode call ProseMode()
  func! CodeMode()
    Goyo!
  endfu
  func! WriteMode()
    " set fo=ant
    setlocal fo=an
    setlocal flp=^\\s*\\(-\\\\|\\d\\+\\.\\)\\s*
        "formtlistpat=^\s*\(-\|\d\+\.\)\s*
    " set formatprg=par\ -jw80
    setlocal nosmartindent
    " ^ this only affects gqip, NOTHING ELSE see [help gq]
    setlocal whichwrap+=h,l
    let g:deoplete#disable_auto_complete = 1
    setlocal sidescrolloff=0
  endfu
  com! WM call WriteMode()
  func! NoWriteMode()
    set fo=croql
    " set flp=^\s*\d\+[\]:.)}\t ]\s*
    set formatprg=""
    set smartindent
    set whichwrap=b,s
    let g:deoplete#disable_auto_complete = 0

    set sidescrolloff=5 " Show next 5 columns while side-scrolling.
  endfu
  com! WMoff call NoWriteMode()

  " I very rarely use this because scrolling can get really funky (a paragraph
  " is either all-visible or all-hidden. It's still nice to have for when you
  " need to read long paragraphs in vim.
  func! SoftWrappedProcessorMode()
    setlocal nonumber
    setlocal noexpandtab
    setlocal wrap
    setlocal linebreak
    setlocal breakindent
    map <buffer> j gj
    map <buffer> k gk
    " setlocal formatprg=par -jw80
    "setlocal spell spelllang=en_us
    "set thesaurus+=/Users/sbrown/.vim/thesaurus/mthesaur.txt
    "set complete+=s
  endfu
  com! SoftWrapMode call SoftWrappedProcessorMode()

" visor style terminal buffer
  " https://www.reddit.com/r/neovim/comments/3cu8fl/quick_visor_style_terminal_buffer/
  let s:termbuf = 0
  function! ToggleTerm()
      topleft 30 split
      try
          exe 'buffer' . s:termbuf
          startinsert
      catch
          terminal
          let s:termbuf=bufnr('%')
          tnoremap <buffer> <A-t>  <C-\><C-n>:close<cr>
      endtry
  endfunction
  com! ToggleTerm call ToggleTerm()
  nnoremap <A-t> :ToggleTerm<cr>


"# GUI Customization
  if has('gui_running')
    set background=dark
    set gfn=Fira\ Mono\ Medium\ for\ Powerline\ Medium\ 10,\ Monaco\ for\ Powerline:h14
    set autoread        "auto-load changes from disk

    :set guioptions-=m  "remove menu bar
    :set guioptions-=T  "remove toolbar
    :set guioptions-=r  "remove right-hand scroll bar
    :set guioptions-=L  "remove left-hand scroll bar
    :set go+=m " I think I want to keep the menu actually
  endif

" Rare Tools
  func! HighlightTrailingSpace()
    highlight TrailingSpace ctermbg=red ctermfg=white guibg=#592929
    match TrailingSpace /\s\+\n/
  endfu
  command! TrailingSpaceHighlight call HighlightTrailingSpace()
  command! TrailingSpaceDeleteAll :%s/\s\+\n//gc

  " call clearmatches() " http://vim.wikia.com/wiki/Highlight_long_lines
  func! HighlightOverlength()
    highlight OverLength ctermbg=red ctermfg=white guibg=#592929
    match OverLength /\%81v.\+/
  endfu
  func! SetWidthEightyFour()
    :vertical resize 84
  endfu

" Basics
  com! FormatBullets setlocal flp=^\\s*\\(-\\\\|\\d\\+\\.\\)\\s* " I want to autoindent paragraphs that start with "- " or "123. "
  if filereadable($VIMRUNTIME . "/defaults.vim")
    source $VIMRUNTIME/defaults.vim " new in vim 8
  else
    set wildmenu      "show suggestions for vim commands
    set incsearch     "incremental search (something else also turns this on)
    syntax enable
    set mouse=a       " default in Vim 8 defaults.vim
    set backspace=indent,eol,start
    set history=200		" keep 200 lines of command line history
  endif
  set ttimeoutlen=0 "timeout instantly when pressing esc during visual mode
  set foldmethod=syntax
  set foldlevelstart=99
  set nowrap
  set ignorecase    "search ignores case
  set smartcase     "unless there's a capital letter
  set number
  set autoindent
  set smartindent
  set hlsearch      " default in NeoVim

  set splitbelow    " more natural split behavior
  set splitright    " more natural split behavior

  set hidden        " leave buffers without saving

  set completeopt=menuone,longest,preview " make completion menu awesome
  set directory=~/.config/vimswap,.

  set sessionoptions-=options " for some reason, vim won't restore with syntax highlighting without this. https://stackoverflow.com/questions/9281438/syntax-highlighting-doesnt-work-after-restore-a-previous-vim-session

  :cabbrev h vert h
                    " execute [:h QUERY] to open help page in vertical split buffer

  if !&scrolloff
    set scrolloff=3 " Show next 3 lines while scrolling.
  endif
  if !&sidescrolloff
    set sidescrolloff=5 " Show next 5 columns while side-scrolling.
  endif
  "(source: http://nerditya.com/code/guide-to-neovim/)

" Tabs
  set expandtab     " SPACES over TABS
  set smarttab      " delete multiple spaces at once (as if deleting a tab character)
  com! -nargs=1 Tab      set      tabstop=<args> | set      shiftwidth=<args> "| set softtabstop=<args>
  com! -nargs=1 LocalTab setlocal tabstop=<args> | setlocal shiftwidth=<args> "| set softtabstop=<args>
  " if (hostname() == "Smithers.local")
  "   :Tab 4
  " elseif (hostname() == "zamperini2")
  "   :Tab 2
  " elseif (hostname() == "zamperini4")
  "   :Tab 2
  " endif

  " autocmd Filetype vimrc setlocal expandtab tabstop=2 shiftwidth=2 softtabstop=2

  func! JSFormatting()
    autocmd FileType javascript setlocal equalprg=js-beautify\ --stdin
  endfu

" Theme shortcuts
  com! DarkGruv   set background=dark  | colorscheme gruvbox
  com! DarkOcean  set background=dark  | colorscheme OceanicNext
  com! DarkPaper  set background=dark  | colorscheme PaperColor
  com! DarkOne    set background=dark  | colorscheme one
  com! DarkSeoul  set background=dark  | colorscheme seoul256
  com! LightOne   set background=light | colorscheme one
  com! LightGruv  set background=light | colorscheme gruvbox
  com! LightOcean set background=light | colorscheme OceanicNextLight
  com! LightPaper set background=light | colorscheme PaperColor
  com! LightSeoul set background=light | colorscheme seoul256

" Neovim specific
  if has('nvim')
    let $NVIM_TUI_ENABLE_TRUE_COLOR=1
    :DarkGruv
    set nofixeol      " don't insert EOL at end of file
    " Deoplete
  else
    "dark ocean
    :DarkOcean
  end

" simple session restoration http://vim.wikia.com/wiki/Go_away_and_come_back
  function! MakeSession()
    let b:sessiondir = $HOME . "/.vim/sessions" . getcwd()
    if (filewritable(b:sessiondir) != 2)
      exe 'silent !mkdir -p ' b:sessiondir
      redraw!
    endif
    let b:filename = b:sessiondir . '/session.vim'
    exe "mksession! " . b:filename
  endfunction

  function! LoadSession()
    let b:sessiondir = $HOME . "/.vim/sessions" . getcwd()
    let b:sessionfile = b:sessiondir . "/session.vim"
    if (filereadable(b:sessionfile))
      exe 'source ' b:sessionfile
    else
      echo "No session loaded."
    endif
  endfunction
  " au VimEnter * nested if argc() == 0 | :call LoadSession() | endif
  au VimLeave * :call MakeSession()
  com! LoadSession call LoadSession()

" Auto Commands
  augroup vimrc_autocomamnds
    autocmd!

    " custom filetype behaviors
    autocmd FileType gitcommit setlocal spell
    autocmd FileType gitcommit startinsert!
    autocmd FileType text     setlocal spell
    autocmd Filetype markdown setlocal spell

    " auto-reload vimrc whenever I save it
    autocmd BufWritePost vimrc,.vimrc,*.vim source $MYVIMRC | call lightline#disable() | call lightline#enable()
    "                                                       "  ^ not entirely sure why all this craziness is necessary. It was necessary with Airline too!

    " disable syntax when editing huge files so vim stays snappy
    autocmd Filetype * if (getfsize(@%) > 500000) | setlocal syntax=OFF | endif
    " auto detect indent for bower component files
    autocmd Filetype * if (IsBowerComponent()) | :DetectIndent | endif

    " code execution
    autocmd Filetype python     nmap <buffer> <space>py :!python %<cr>
    autocmd Filetype javascript nmap <buffer> <space>js :!node %<cr>
    autocmd Filetype javascript,html call MakeJSKeys()

  augroup END

  function! MakeJSKeys()
    :nmap <buffer> <Leader>il oconsole.log();F)i
    :nmap <buffer> <Leader>iL oconsole.log('%c', 'font-size:15px');F,hi
    :nmap <buffer> <Leader>liw yiwoconsole.log('0', 0);<Esc>
    :nmap <buffer> <Leader>lif yiwoconsole.log('0()');<Esc>
    :nmap <buffer> <Leader>liF yiwoconsole.log('%c0()', 'font-size:15px');<Esc>^2w
    :nmap <buffer> <Leader>gif yiwf{oconsole.group('0');<Esc>]}Oconsole.groupEnd();<Esc>^
  endfunction

  function! IsBowerComponent()
    return @% =~ 'bower_components'
  endfunction

  " lil debugging util
  com! -nargs=1 Log execute 'silent! ! echo ' . fnameescape(<args>) . ' >> VIM_LOG'
let s:vimrcIsExecuting = 0
